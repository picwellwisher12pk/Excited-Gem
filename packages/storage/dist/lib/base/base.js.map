{
  "version": 3,
  "sources": ["../../../lib/base/base.ts"],
  "sourcesContent": ["import type { BaseStorage, StorageConfig, ValueOrUpdate } from './types';\nimport { SessionAccessLevelEnum, StorageEnum } from './enums';\n\n/**\n * Chrome reference error while running `processTailwindFeatures` in tailwindcss.\n *  To avoid this, we need to check if the globalThis.chrome is available and add fallback logic.\n */\nconst chrome = globalThis.chrome;\n\n/**\n * Sets or updates an arbitrary cache with a new value or the result of an update function.\n */\nasync function updateCache<D>(valueOrUpdate: ValueOrUpdate<D>, cache: D | null): Promise<D> {\n  // Type guard to check if our value or update is a function\n  function isFunction<D>(value: ValueOrUpdate<D>): value is (prev: D) => D | Promise<D> {\n    return typeof value === 'function';\n  }\n\n  // Type guard to check in case of a function, if its a Promise\n  function returnsPromise<D>(func: (prev: D) => D | Promise<D>): func is (prev: D) => Promise<D> {\n    // Use ReturnType to infer the return type of the function and check if it's a Promise\n    return (func as (prev: D) => Promise<D>) instanceof Promise;\n  }\n\n  if (isFunction(valueOrUpdate)) {\n    // Check if the function returns a Promise\n    if (returnsPromise(valueOrUpdate)) {\n      return valueOrUpdate(cache as D);\n    } else {\n      return valueOrUpdate(cache as D);\n    }\n  } else {\n    return valueOrUpdate;\n  }\n}\n\n/**\n * If one session storage needs access from content scripts, we need to enable it globally.\n * @default false\n */\nlet globalSessionAccessLevelFlag: StorageConfig['sessionAccessForContentScripts'] = false;\n\n/**\n * Checks if the storage permission is granted in the manifest.json.\n */\nfunction checkStoragePermission(storageEnum: StorageEnum): void {\n  if (!chrome) {\n    return;\n  }\n\n  if (chrome.storage[storageEnum] === undefined) {\n    throw new Error(`Check your storage permission in manifest.json: ${storageEnum} is not defined`);\n  }\n}\n\n/**\n * Creates a storage area for persisting and exchanging data.\n */\nexport function createStorage<D = string>(key: string, fallback: D, config?: StorageConfig<D>): BaseStorage<D> {\n  let cache: D | null = null;\n  let initedCache = false;\n  let listeners: Array<() => void> = [];\n\n  const storageEnum = config?.storageEnum ?? StorageEnum.Local;\n  const liveUpdate = config?.liveUpdate ?? false;\n\n  const serialize = config?.serialization?.serialize ?? ((v: D) => v);\n  const deserialize = config?.serialization?.deserialize ?? (v => v as D);\n\n  // Set global session storage access level for StoryType.Session, only when not already done but needed.\n  if (\n    globalSessionAccessLevelFlag === false &&\n    storageEnum === StorageEnum.Session &&\n    config?.sessionAccessForContentScripts === true\n  ) {\n    checkStoragePermission(storageEnum);\n    chrome?.storage[storageEnum]\n      .setAccessLevel({\n        accessLevel: SessionAccessLevelEnum.ExtensionPagesAndContentScripts,\n      })\n      .catch(error => {\n        console.warn(error);\n        console.warn('Please call setAccessLevel into different context, like a background script.');\n      });\n    globalSessionAccessLevelFlag = true;\n  }\n\n  // Register life cycle methods\n  const get = async (): Promise<D> => {\n    checkStoragePermission(storageEnum);\n    const value = await chrome?.storage[storageEnum].get([key]);\n\n    if (!value) {\n      return fallback;\n    }\n\n    return deserialize(value[key]) ?? fallback;\n  };\n\n  const _emitChange = () => {\n    listeners.forEach(listener => listener());\n  };\n\n  const set = async (valueOrUpdate: ValueOrUpdate<D>) => {\n    if (initedCache === false) {\n      cache = await get();\n    }\n    cache = await updateCache(valueOrUpdate, cache);\n\n    await chrome?.storage[storageEnum].set({ [key]: serialize(cache) });\n    _emitChange();\n  };\n\n  const subscribe = (listener: () => void) => {\n    listeners = [...listeners, listener];\n\n    return () => {\n      listeners = listeners.filter(l => l !== listener);\n    };\n  };\n\n  const getSnapshot = () => {\n    return cache;\n  };\n\n  get().then(data => {\n    cache = data;\n    initedCache = true;\n    _emitChange();\n  });\n\n  // Listener for live updates from the browser\n  async function _updateFromStorageOnChanged(changes: { [key: string]: chrome.storage.StorageChange }) {\n    // Check if the key we are listening for is in the changes object\n    if (changes[key] === undefined) return;\n\n    const valueOrUpdate: ValueOrUpdate<D> = deserialize(changes[key].newValue);\n\n    if (cache === valueOrUpdate) return;\n\n    cache = await updateCache(valueOrUpdate, cache);\n\n    _emitChange();\n  }\n\n  // Register listener for live updates for our storage area\n  if (liveUpdate) {\n    chrome?.storage[storageEnum].onChanged.addListener(_updateFromStorageOnChanged);\n  }\n\n  return {\n    get,\n    set,\n    getSnapshot,\n    subscribe,\n  };\n}\n"],
  "mappings": "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",
  "names": ["_a"]
}
